// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/ugent-library/oai-service/ent/metadataformat"
	"github.com/ugent-library/oai-service/ent/predicate"
	"github.com/ugent-library/oai-service/ent/record"
	"github.com/ugent-library/oai-service/ent/set"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMetadataFormat = "MetadataFormat"
	TypeRecord         = "Record"
	TypeSet            = "Set"
)

// MetadataFormatMutation represents an operation that mutates the MetadataFormat nodes in the graph.
type MetadataFormatMutation struct {
	config
	op             Op
	typ            string
	id             *int
	prefix         *string
	schema         *string
	namespace      *string
	clearedFields  map[string]struct{}
	records        map[int]struct{}
	removedrecords map[int]struct{}
	clearedrecords bool
	done           bool
	oldValue       func(context.Context) (*MetadataFormat, error)
	predicates     []predicate.MetadataFormat
}

var _ ent.Mutation = (*MetadataFormatMutation)(nil)

// metadataformatOption allows management of the mutation configuration using functional options.
type metadataformatOption func(*MetadataFormatMutation)

// newMetadataFormatMutation creates new mutation for the MetadataFormat entity.
func newMetadataFormatMutation(c config, op Op, opts ...metadataformatOption) *MetadataFormatMutation {
	m := &MetadataFormatMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadataFormat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataFormatID sets the ID field of the mutation.
func withMetadataFormatID(id int) metadataformatOption {
	return func(m *MetadataFormatMutation) {
		var (
			err   error
			once  sync.Once
			value *MetadataFormat
		)
		m.oldValue = func(ctx context.Context) (*MetadataFormat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetadataFormat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadataFormat sets the old MetadataFormat of the mutation.
func withMetadataFormat(node *MetadataFormat) metadataformatOption {
	return func(m *MetadataFormatMutation) {
		m.oldValue = func(context.Context) (*MetadataFormat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataFormatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataFormatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataFormatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataFormatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MetadataFormat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrefix sets the "prefix" field.
func (m *MetadataFormatMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *MetadataFormatMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the MetadataFormat entity.
// If the MetadataFormat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataFormatMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *MetadataFormatMutation) ResetPrefix() {
	m.prefix = nil
}

// SetSchema sets the "schema" field.
func (m *MetadataFormatMutation) SetSchema(s string) {
	m.schema = &s
}

// Schema returns the value of the "schema" field in the mutation.
func (m *MetadataFormatMutation) Schema() (r string, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the MetadataFormat entity.
// If the MetadataFormat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataFormatMutation) OldSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ResetSchema resets all changes to the "schema" field.
func (m *MetadataFormatMutation) ResetSchema() {
	m.schema = nil
}

// SetNamespace sets the "namespace" field.
func (m *MetadataFormatMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *MetadataFormatMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the MetadataFormat entity.
// If the MetadataFormat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataFormatMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *MetadataFormatMutation) ResetNamespace() {
	m.namespace = nil
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *MetadataFormatMutation) AddRecordIDs(ids ...int) {
	if m.records == nil {
		m.records = make(map[int]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *MetadataFormatMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *MetadataFormatMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *MetadataFormatMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *MetadataFormatMutation) RemovedRecordsIDs() (ids []int) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *MetadataFormatMutation) RecordsIDs() (ids []int) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *MetadataFormatMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the MetadataFormatMutation builder.
func (m *MetadataFormatMutation) Where(ps ...predicate.MetadataFormat) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetadataFormatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MetadataFormat).
func (m *MetadataFormatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataFormatMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.prefix != nil {
		fields = append(fields, metadataformat.FieldPrefix)
	}
	if m.schema != nil {
		fields = append(fields, metadataformat.FieldSchema)
	}
	if m.namespace != nil {
		fields = append(fields, metadataformat.FieldNamespace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataFormatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadataformat.FieldPrefix:
		return m.Prefix()
	case metadataformat.FieldSchema:
		return m.Schema()
	case metadataformat.FieldNamespace:
		return m.Namespace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataFormatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadataformat.FieldPrefix:
		return m.OldPrefix(ctx)
	case metadataformat.FieldSchema:
		return m.OldSchema(ctx)
	case metadataformat.FieldNamespace:
		return m.OldNamespace(ctx)
	}
	return nil, fmt.Errorf("unknown MetadataFormat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataFormatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadataformat.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case metadataformat.FieldSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	case metadataformat.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	}
	return fmt.Errorf("unknown MetadataFormat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataFormatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataFormatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataFormatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MetadataFormat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataFormatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataFormatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataFormatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MetadataFormat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataFormatMutation) ResetField(name string) error {
	switch name {
	case metadataformat.FieldPrefix:
		m.ResetPrefix()
		return nil
	case metadataformat.FieldSchema:
		m.ResetSchema()
		return nil
	case metadataformat.FieldNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown MetadataFormat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataFormatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.records != nil {
		edges = append(edges, metadataformat.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataFormatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadataformat.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataFormatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecords != nil {
		edges = append(edges, metadataformat.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataFormatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metadataformat.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataFormatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecords {
		edges = append(edges, metadataformat.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataFormatMutation) EdgeCleared(name string) bool {
	switch name {
	case metadataformat.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataFormatMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MetadataFormat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataFormatMutation) ResetEdge(name string) error {
	switch name {
	case metadataformat.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown MetadataFormat edge %s", name)
}

// RecordMutation represents an operation that mutates the Record nodes in the graph.
type RecordMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	identifier             *string
	metadata               *string
	deleted                *bool
	datestamp              *time.Time
	clearedFields          map[string]struct{}
	metadata_format        *int
	clearedmetadata_format bool
	sets                   map[int]struct{}
	removedsets            map[int]struct{}
	clearedsets            bool
	done                   bool
	oldValue               func(context.Context) (*Record, error)
	predicates             []predicate.Record
}

var _ ent.Mutation = (*RecordMutation)(nil)

// recordOption allows management of the mutation configuration using functional options.
type recordOption func(*RecordMutation)

// newRecordMutation creates new mutation for the Record entity.
func newRecordMutation(c config, op Op, opts ...recordOption) *RecordMutation {
	m := &RecordMutation{
		config:        c,
		op:            op,
		typ:           TypeRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecordID sets the ID field of the mutation.
func withRecordID(id int) recordOption {
	return func(m *RecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Record
		)
		m.oldValue = func(ctx context.Context) (*Record, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Record.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecord sets the old Record of the mutation.
func withRecord(node *Record) recordOption {
	return func(m *RecordMutation) {
		m.oldValue = func(context.Context) (*Record, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Record.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMetadataFormatID sets the "metadata_format_id" field.
func (m *RecordMutation) SetMetadataFormatID(i int) {
	m.metadata_format = &i
}

// MetadataFormatID returns the value of the "metadata_format_id" field in the mutation.
func (m *RecordMutation) MetadataFormatID() (r int, exists bool) {
	v := m.metadata_format
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataFormatID returns the old "metadata_format_id" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldMetadataFormatID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataFormatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataFormatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataFormatID: %w", err)
	}
	return oldValue.MetadataFormatID, nil
}

// ResetMetadataFormatID resets all changes to the "metadata_format_id" field.
func (m *RecordMutation) ResetMetadataFormatID() {
	m.metadata_format = nil
}

// SetIdentifier sets the "identifier" field.
func (m *RecordMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *RecordMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *RecordMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetMetadata sets the "metadata" field.
func (m *RecordMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *RecordMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *RecordMutation) ResetMetadata() {
	m.metadata = nil
}

// SetDeleted sets the "deleted" field.
func (m *RecordMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *RecordMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *RecordMutation) ResetDeleted() {
	m.deleted = nil
}

// SetDatestamp sets the "datestamp" field.
func (m *RecordMutation) SetDatestamp(t time.Time) {
	m.datestamp = &t
}

// Datestamp returns the value of the "datestamp" field in the mutation.
func (m *RecordMutation) Datestamp() (r time.Time, exists bool) {
	v := m.datestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldDatestamp returns the old "datestamp" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldDatestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatestamp: %w", err)
	}
	return oldValue.Datestamp, nil
}

// ResetDatestamp resets all changes to the "datestamp" field.
func (m *RecordMutation) ResetDatestamp() {
	m.datestamp = nil
}

// ClearMetadataFormat clears the "metadata_format" edge to the MetadataFormat entity.
func (m *RecordMutation) ClearMetadataFormat() {
	m.clearedmetadata_format = true
}

// MetadataFormatCleared reports if the "metadata_format" edge to the MetadataFormat entity was cleared.
func (m *RecordMutation) MetadataFormatCleared() bool {
	return m.clearedmetadata_format
}

// MetadataFormatIDs returns the "metadata_format" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataFormatID instead. It exists only for internal usage by the builders.
func (m *RecordMutation) MetadataFormatIDs() (ids []int) {
	if id := m.metadata_format; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadataFormat resets all changes to the "metadata_format" edge.
func (m *RecordMutation) ResetMetadataFormat() {
	m.metadata_format = nil
	m.clearedmetadata_format = false
}

// AddSetIDs adds the "sets" edge to the Set entity by ids.
func (m *RecordMutation) AddSetIDs(ids ...int) {
	if m.sets == nil {
		m.sets = make(map[int]struct{})
	}
	for i := range ids {
		m.sets[ids[i]] = struct{}{}
	}
}

// ClearSets clears the "sets" edge to the Set entity.
func (m *RecordMutation) ClearSets() {
	m.clearedsets = true
}

// SetsCleared reports if the "sets" edge to the Set entity was cleared.
func (m *RecordMutation) SetsCleared() bool {
	return m.clearedsets
}

// RemoveSetIDs removes the "sets" edge to the Set entity by IDs.
func (m *RecordMutation) RemoveSetIDs(ids ...int) {
	if m.removedsets == nil {
		m.removedsets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sets, ids[i])
		m.removedsets[ids[i]] = struct{}{}
	}
}

// RemovedSets returns the removed IDs of the "sets" edge to the Set entity.
func (m *RecordMutation) RemovedSetsIDs() (ids []int) {
	for id := range m.removedsets {
		ids = append(ids, id)
	}
	return
}

// SetsIDs returns the "sets" edge IDs in the mutation.
func (m *RecordMutation) SetsIDs() (ids []int) {
	for id := range m.sets {
		ids = append(ids, id)
	}
	return
}

// ResetSets resets all changes to the "sets" edge.
func (m *RecordMutation) ResetSets() {
	m.sets = nil
	m.clearedsets = false
	m.removedsets = nil
}

// Where appends a list predicates to the RecordMutation builder.
func (m *RecordMutation) Where(ps ...predicate.Record) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Record).
func (m *RecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecordMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.metadata_format != nil {
		fields = append(fields, record.FieldMetadataFormatID)
	}
	if m.identifier != nil {
		fields = append(fields, record.FieldIdentifier)
	}
	if m.metadata != nil {
		fields = append(fields, record.FieldMetadata)
	}
	if m.deleted != nil {
		fields = append(fields, record.FieldDeleted)
	}
	if m.datestamp != nil {
		fields = append(fields, record.FieldDatestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case record.FieldMetadataFormatID:
		return m.MetadataFormatID()
	case record.FieldIdentifier:
		return m.Identifier()
	case record.FieldMetadata:
		return m.Metadata()
	case record.FieldDeleted:
		return m.Deleted()
	case record.FieldDatestamp:
		return m.Datestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case record.FieldMetadataFormatID:
		return m.OldMetadataFormatID(ctx)
	case record.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case record.FieldMetadata:
		return m.OldMetadata(ctx)
	case record.FieldDeleted:
		return m.OldDeleted(ctx)
	case record.FieldDatestamp:
		return m.OldDatestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Record field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case record.FieldMetadataFormatID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataFormatID(v)
		return nil
	case record.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case record.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case record.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case record.FieldDatestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecordMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Record numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Record nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecordMutation) ResetField(name string) error {
	switch name {
	case record.FieldMetadataFormatID:
		m.ResetMetadataFormatID()
		return nil
	case record.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case record.FieldMetadata:
		m.ResetMetadata()
		return nil
	case record.FieldDeleted:
		m.ResetDeleted()
		return nil
	case record.FieldDatestamp:
		m.ResetDatestamp()
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata_format != nil {
		edges = append(edges, record.EdgeMetadataFormat)
	}
	if m.sets != nil {
		edges = append(edges, record.EdgeSets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case record.EdgeMetadataFormat:
		if id := m.metadata_format; id != nil {
			return []ent.Value{*id}
		}
	case record.EdgeSets:
		ids := make([]ent.Value, 0, len(m.sets))
		for id := range m.sets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsets != nil {
		edges = append(edges, record.EdgeSets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case record.EdgeSets:
		ids := make([]ent.Value, 0, len(m.removedsets))
		for id := range m.removedsets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata_format {
		edges = append(edges, record.EdgeMetadataFormat)
	}
	if m.clearedsets {
		edges = append(edges, record.EdgeSets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecordMutation) EdgeCleared(name string) bool {
	switch name {
	case record.EdgeMetadataFormat:
		return m.clearedmetadata_format
	case record.EdgeSets:
		return m.clearedsets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecordMutation) ClearEdge(name string) error {
	switch name {
	case record.EdgeMetadataFormat:
		m.ClearMetadataFormat()
		return nil
	}
	return fmt.Errorf("unknown Record unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecordMutation) ResetEdge(name string) error {
	switch name {
	case record.EdgeMetadataFormat:
		m.ResetMetadataFormat()
		return nil
	case record.EdgeSets:
		m.ResetSets()
		return nil
	}
	return fmt.Errorf("unknown Record edge %s", name)
}

// SetMutation represents an operation that mutates the Set nodes in the graph.
type SetMutation struct {
	config
	op             Op
	typ            string
	id             *int
	spec           *string
	name           *string
	description    *string
	clearedFields  map[string]struct{}
	records        map[int]struct{}
	removedrecords map[int]struct{}
	clearedrecords bool
	done           bool
	oldValue       func(context.Context) (*Set, error)
	predicates     []predicate.Set
}

var _ ent.Mutation = (*SetMutation)(nil)

// setOption allows management of the mutation configuration using functional options.
type setOption func(*SetMutation)

// newSetMutation creates new mutation for the Set entity.
func newSetMutation(c config, op Op, opts ...setOption) *SetMutation {
	m := &SetMutation{
		config:        c,
		op:            op,
		typ:           TypeSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetID sets the ID field of the mutation.
func withSetID(id int) setOption {
	return func(m *SetMutation) {
		var (
			err   error
			once  sync.Once
			value *Set
		)
		m.oldValue = func(ctx context.Context) (*Set, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Set.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSet sets the old Set of the mutation.
func withSet(node *Set) setOption {
	return func(m *SetMutation) {
		m.oldValue = func(context.Context) (*Set, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Set.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpec sets the "spec" field.
func (m *SetMutation) SetSpec(s string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *SetMutation) Spec() (r string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldSpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ResetSpec resets all changes to the "spec" field.
func (m *SetMutation) ResetSpec() {
	m.spec = nil
}

// SetName sets the "name" field.
func (m *SetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SetMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SetMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[set.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SetMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[set.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SetMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, set.FieldDescription)
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *SetMutation) AddRecordIDs(ids ...int) {
	if m.records == nil {
		m.records = make(map[int]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *SetMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *SetMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *SetMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *SetMutation) RemovedRecordsIDs() (ids []int) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *SetMutation) RecordsIDs() (ids []int) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *SetMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the SetMutation builder.
func (m *SetMutation) Where(ps ...predicate.Set) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Set).
func (m *SetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.spec != nil {
		fields = append(fields, set.FieldSpec)
	}
	if m.name != nil {
		fields = append(fields, set.FieldName)
	}
	if m.description != nil {
		fields = append(fields, set.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case set.FieldSpec:
		return m.Spec()
	case set.FieldName:
		return m.Name()
	case set.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case set.FieldSpec:
		return m.OldSpec(ctx)
	case set.FieldName:
		return m.OldName(ctx)
	case set.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Set field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case set.FieldSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case set.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case set.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Set numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(set.FieldDescription) {
		fields = append(fields, set.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMutation) ClearField(name string) error {
	switch name {
	case set.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Set nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMutation) ResetField(name string) error {
	switch name {
	case set.FieldSpec:
		m.ResetSpec()
		return nil
	case set.FieldName:
		m.ResetName()
		return nil
	case set.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.records != nil {
		edges = append(edges, set.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecords != nil {
		edges = append(edges, set.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecords {
		edges = append(edges, set.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMutation) EdgeCleared(name string) bool {
	switch name {
	case set.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Set unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMutation) ResetEdge(name string) error {
	switch name {
	case set.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown Set edge %s", name)
}
