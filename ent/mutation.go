// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ugent-library/oai-service/ent/metadata"
	"github.com/ugent-library/oai-service/ent/metadataformat"
	"github.com/ugent-library/oai-service/ent/predicate"
	"github.com/ugent-library/oai-service/ent/record"
	"github.com/ugent-library/oai-service/ent/set"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMetadata       = "Metadata"
	TypeMetadataFormat = "MetadataFormat"
	TypeRecord         = "Record"
	TypeSet            = "Set"
)

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	content                *string
	datestamp              *time.Time
	clearedFields          map[string]struct{}
	record                 *int64
	clearedrecord          bool
	metadata_format        *int64
	clearedmetadata_format bool
	done                   bool
	oldValue               func(context.Context) (*Metadata, error)
	predicates             []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id int64) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metadata entities.
func (m *MetadataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecordID sets the "record_id" field.
func (m *MetadataMutation) SetRecordID(i int64) {
	m.record = &i
}

// RecordID returns the value of the "record_id" field in the mutation.
func (m *MetadataMutation) RecordID() (r int64, exists bool) {
	v := m.record
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordID returns the old "record_id" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldRecordID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordID: %w", err)
	}
	return oldValue.RecordID, nil
}

// ResetRecordID resets all changes to the "record_id" field.
func (m *MetadataMutation) ResetRecordID() {
	m.record = nil
}

// SetMetadataFormatID sets the "metadata_format_id" field.
func (m *MetadataMutation) SetMetadataFormatID(i int64) {
	m.metadata_format = &i
}

// MetadataFormatID returns the value of the "metadata_format_id" field in the mutation.
func (m *MetadataMutation) MetadataFormatID() (r int64, exists bool) {
	v := m.metadata_format
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataFormatID returns the old "metadata_format_id" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldMetadataFormatID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataFormatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataFormatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataFormatID: %w", err)
	}
	return oldValue.MetadataFormatID, nil
}

// ResetMetadataFormatID resets all changes to the "metadata_format_id" field.
func (m *MetadataMutation) ResetMetadataFormatID() {
	m.metadata_format = nil
}

// SetContent sets the "content" field.
func (m *MetadataMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MetadataMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MetadataMutation) ResetContent() {
	m.content = nil
}

// SetDatestamp sets the "datestamp" field.
func (m *MetadataMutation) SetDatestamp(t time.Time) {
	m.datestamp = &t
}

// Datestamp returns the value of the "datestamp" field in the mutation.
func (m *MetadataMutation) Datestamp() (r time.Time, exists bool) {
	v := m.datestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldDatestamp returns the old "datestamp" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDatestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatestamp: %w", err)
	}
	return oldValue.Datestamp, nil
}

// ResetDatestamp resets all changes to the "datestamp" field.
func (m *MetadataMutation) ResetDatestamp() {
	m.datestamp = nil
}

// ClearRecord clears the "record" edge to the Record entity.
func (m *MetadataMutation) ClearRecord() {
	m.clearedrecord = true
}

// RecordCleared reports if the "record" edge to the Record entity was cleared.
func (m *MetadataMutation) RecordCleared() bool {
	return m.clearedrecord
}

// RecordIDs returns the "record" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecordID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) RecordIDs() (ids []int64) {
	if id := m.record; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecord resets all changes to the "record" edge.
func (m *MetadataMutation) ResetRecord() {
	m.record = nil
	m.clearedrecord = false
}

// ClearMetadataFormat clears the "metadata_format" edge to the MetadataFormat entity.
func (m *MetadataMutation) ClearMetadataFormat() {
	m.clearedmetadata_format = true
}

// MetadataFormatCleared reports if the "metadata_format" edge to the MetadataFormat entity was cleared.
func (m *MetadataMutation) MetadataFormatCleared() bool {
	return m.clearedmetadata_format
}

// MetadataFormatIDs returns the "metadata_format" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataFormatID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) MetadataFormatIDs() (ids []int64) {
	if id := m.metadata_format; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadataFormat resets all changes to the "metadata_format" edge.
func (m *MetadataMutation) ResetMetadataFormat() {
	m.metadata_format = nil
	m.clearedmetadata_format = false
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.record != nil {
		fields = append(fields, metadata.FieldRecordID)
	}
	if m.metadata_format != nil {
		fields = append(fields, metadata.FieldMetadataFormatID)
	}
	if m.content != nil {
		fields = append(fields, metadata.FieldContent)
	}
	if m.datestamp != nil {
		fields = append(fields, metadata.FieldDatestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldRecordID:
		return m.RecordID()
	case metadata.FieldMetadataFormatID:
		return m.MetadataFormatID()
	case metadata.FieldContent:
		return m.Content()
	case metadata.FieldDatestamp:
		return m.Datestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldRecordID:
		return m.OldRecordID(ctx)
	case metadata.FieldMetadataFormatID:
		return m.OldMetadataFormatID(ctx)
	case metadata.FieldContent:
		return m.OldContent(ctx)
	case metadata.FieldDatestamp:
		return m.OldDatestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldRecordID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordID(v)
		return nil
	case metadata.FieldMetadataFormatID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataFormatID(v)
		return nil
	case metadata.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case metadata.FieldDatestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldRecordID:
		m.ResetRecordID()
		return nil
	case metadata.FieldMetadataFormatID:
		m.ResetMetadataFormatID()
		return nil
	case metadata.FieldContent:
		m.ResetContent()
		return nil
	case metadata.FieldDatestamp:
		m.ResetDatestamp()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.record != nil {
		edges = append(edges, metadata.EdgeRecord)
	}
	if m.metadata_format != nil {
		edges = append(edges, metadata.EdgeMetadataFormat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeRecord:
		if id := m.record; id != nil {
			return []ent.Value{*id}
		}
	case metadata.EdgeMetadataFormat:
		if id := m.metadata_format; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrecord {
		edges = append(edges, metadata.EdgeRecord)
	}
	if m.clearedmetadata_format {
		edges = append(edges, metadata.EdgeMetadataFormat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeRecord:
		return m.clearedrecord
	case metadata.EdgeMetadataFormat:
		return m.clearedmetadata_format
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeRecord:
		m.ClearRecord()
		return nil
	case metadata.EdgeMetadataFormat:
		m.ClearMetadataFormat()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeRecord:
		m.ResetRecord()
		return nil
	case metadata.EdgeMetadataFormat:
		m.ResetMetadataFormat()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// MetadataFormatMutation represents an operation that mutates the MetadataFormat nodes in the graph.
type MetadataFormatMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	metadata_prefix    *string
	schema             *string
	metadata_namespace *string
	clearedFields      map[string]struct{}
	metadata           map[int64]struct{}
	removedmetadata    map[int64]struct{}
	clearedmetadata    bool
	done               bool
	oldValue           func(context.Context) (*MetadataFormat, error)
	predicates         []predicate.MetadataFormat
}

var _ ent.Mutation = (*MetadataFormatMutation)(nil)

// metadataformatOption allows management of the mutation configuration using functional options.
type metadataformatOption func(*MetadataFormatMutation)

// newMetadataFormatMutation creates new mutation for the MetadataFormat entity.
func newMetadataFormatMutation(c config, op Op, opts ...metadataformatOption) *MetadataFormatMutation {
	m := &MetadataFormatMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadataFormat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataFormatID sets the ID field of the mutation.
func withMetadataFormatID(id int64) metadataformatOption {
	return func(m *MetadataFormatMutation) {
		var (
			err   error
			once  sync.Once
			value *MetadataFormat
		)
		m.oldValue = func(ctx context.Context) (*MetadataFormat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetadataFormat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadataFormat sets the old MetadataFormat of the mutation.
func withMetadataFormat(node *MetadataFormat) metadataformatOption {
	return func(m *MetadataFormatMutation) {
		m.oldValue = func(context.Context) (*MetadataFormat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataFormatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataFormatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MetadataFormat entities.
func (m *MetadataFormatMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataFormatMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataFormatMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MetadataFormat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMetadataPrefix sets the "metadata_prefix" field.
func (m *MetadataFormatMutation) SetMetadataPrefix(s string) {
	m.metadata_prefix = &s
}

// MetadataPrefix returns the value of the "metadata_prefix" field in the mutation.
func (m *MetadataFormatMutation) MetadataPrefix() (r string, exists bool) {
	v := m.metadata_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataPrefix returns the old "metadata_prefix" field's value of the MetadataFormat entity.
// If the MetadataFormat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataFormatMutation) OldMetadataPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataPrefix: %w", err)
	}
	return oldValue.MetadataPrefix, nil
}

// ResetMetadataPrefix resets all changes to the "metadata_prefix" field.
func (m *MetadataFormatMutation) ResetMetadataPrefix() {
	m.metadata_prefix = nil
}

// SetSchema sets the "schema" field.
func (m *MetadataFormatMutation) SetSchema(s string) {
	m.schema = &s
}

// Schema returns the value of the "schema" field in the mutation.
func (m *MetadataFormatMutation) Schema() (r string, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the MetadataFormat entity.
// If the MetadataFormat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataFormatMutation) OldSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ResetSchema resets all changes to the "schema" field.
func (m *MetadataFormatMutation) ResetSchema() {
	m.schema = nil
}

// SetMetadataNamespace sets the "metadata_namespace" field.
func (m *MetadataFormatMutation) SetMetadataNamespace(s string) {
	m.metadata_namespace = &s
}

// MetadataNamespace returns the value of the "metadata_namespace" field in the mutation.
func (m *MetadataFormatMutation) MetadataNamespace() (r string, exists bool) {
	v := m.metadata_namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataNamespace returns the old "metadata_namespace" field's value of the MetadataFormat entity.
// If the MetadataFormat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataFormatMutation) OldMetadataNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataNamespace: %w", err)
	}
	return oldValue.MetadataNamespace, nil
}

// ResetMetadataNamespace resets all changes to the "metadata_namespace" field.
func (m *MetadataFormatMutation) ResetMetadataNamespace() {
	m.metadata_namespace = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *MetadataFormatMutation) AddMetadatumIDs(ids ...int64) {
	if m.metadata == nil {
		m.metadata = make(map[int64]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *MetadataFormatMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *MetadataFormatMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *MetadataFormatMutation) RemoveMetadatumIDs(ids ...int64) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *MetadataFormatMutation) RemovedMetadataIDs() (ids []int64) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *MetadataFormatMutation) MetadataIDs() (ids []int64) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *MetadataFormatMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the MetadataFormatMutation builder.
func (m *MetadataFormatMutation) Where(ps ...predicate.MetadataFormat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataFormatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataFormatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MetadataFormat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataFormatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataFormatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MetadataFormat).
func (m *MetadataFormatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataFormatMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.metadata_prefix != nil {
		fields = append(fields, metadataformat.FieldMetadataPrefix)
	}
	if m.schema != nil {
		fields = append(fields, metadataformat.FieldSchema)
	}
	if m.metadata_namespace != nil {
		fields = append(fields, metadataformat.FieldMetadataNamespace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataFormatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadataformat.FieldMetadataPrefix:
		return m.MetadataPrefix()
	case metadataformat.FieldSchema:
		return m.Schema()
	case metadataformat.FieldMetadataNamespace:
		return m.MetadataNamespace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataFormatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadataformat.FieldMetadataPrefix:
		return m.OldMetadataPrefix(ctx)
	case metadataformat.FieldSchema:
		return m.OldSchema(ctx)
	case metadataformat.FieldMetadataNamespace:
		return m.OldMetadataNamespace(ctx)
	}
	return nil, fmt.Errorf("unknown MetadataFormat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataFormatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadataformat.FieldMetadataPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataPrefix(v)
		return nil
	case metadataformat.FieldSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	case metadataformat.FieldMetadataNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataNamespace(v)
		return nil
	}
	return fmt.Errorf("unknown MetadataFormat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataFormatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataFormatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataFormatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MetadataFormat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataFormatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataFormatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataFormatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MetadataFormat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataFormatMutation) ResetField(name string) error {
	switch name {
	case metadataformat.FieldMetadataPrefix:
		m.ResetMetadataPrefix()
		return nil
	case metadataformat.FieldSchema:
		m.ResetSchema()
		return nil
	case metadataformat.FieldMetadataNamespace:
		m.ResetMetadataNamespace()
		return nil
	}
	return fmt.Errorf("unknown MetadataFormat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataFormatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metadata != nil {
		edges = append(edges, metadataformat.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataFormatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadataformat.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataFormatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmetadata != nil {
		edges = append(edges, metadataformat.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataFormatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metadataformat.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataFormatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetadata {
		edges = append(edges, metadataformat.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataFormatMutation) EdgeCleared(name string) bool {
	switch name {
	case metadataformat.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataFormatMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MetadataFormat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataFormatMutation) ResetEdge(name string) error {
	switch name {
	case metadataformat.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown MetadataFormat edge %s", name)
}

// RecordMutation represents an operation that mutates the Record nodes in the graph.
type RecordMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	identifier      *string
	deleted         *bool
	clearedFields   map[string]struct{}
	metadata        map[int64]struct{}
	removedmetadata map[int64]struct{}
	clearedmetadata bool
	sets            map[int64]struct{}
	removedsets     map[int64]struct{}
	clearedsets     bool
	done            bool
	oldValue        func(context.Context) (*Record, error)
	predicates      []predicate.Record
}

var _ ent.Mutation = (*RecordMutation)(nil)

// recordOption allows management of the mutation configuration using functional options.
type recordOption func(*RecordMutation)

// newRecordMutation creates new mutation for the Record entity.
func newRecordMutation(c config, op Op, opts ...recordOption) *RecordMutation {
	m := &RecordMutation{
		config:        c,
		op:            op,
		typ:           TypeRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecordID sets the ID field of the mutation.
func withRecordID(id int64) recordOption {
	return func(m *RecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Record
		)
		m.oldValue = func(ctx context.Context) (*Record, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Record.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecord sets the old Record of the mutation.
func withRecord(node *Record) recordOption {
	return func(m *RecordMutation) {
		m.oldValue = func(context.Context) (*Record, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Record entities.
func (m *RecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Record.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdentifier sets the "identifier" field.
func (m *RecordMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *RecordMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *RecordMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetDeleted sets the "deleted" field.
func (m *RecordMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *RecordMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *RecordMutation) ResetDeleted() {
	m.deleted = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *RecordMutation) AddMetadatumIDs(ids ...int64) {
	if m.metadata == nil {
		m.metadata = make(map[int64]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *RecordMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *RecordMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *RecordMutation) RemoveMetadatumIDs(ids ...int64) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *RecordMutation) RemovedMetadataIDs() (ids []int64) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *RecordMutation) MetadataIDs() (ids []int64) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *RecordMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddSetIDs adds the "sets" edge to the Set entity by ids.
func (m *RecordMutation) AddSetIDs(ids ...int64) {
	if m.sets == nil {
		m.sets = make(map[int64]struct{})
	}
	for i := range ids {
		m.sets[ids[i]] = struct{}{}
	}
}

// ClearSets clears the "sets" edge to the Set entity.
func (m *RecordMutation) ClearSets() {
	m.clearedsets = true
}

// SetsCleared reports if the "sets" edge to the Set entity was cleared.
func (m *RecordMutation) SetsCleared() bool {
	return m.clearedsets
}

// RemoveSetIDs removes the "sets" edge to the Set entity by IDs.
func (m *RecordMutation) RemoveSetIDs(ids ...int64) {
	if m.removedsets == nil {
		m.removedsets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sets, ids[i])
		m.removedsets[ids[i]] = struct{}{}
	}
}

// RemovedSets returns the removed IDs of the "sets" edge to the Set entity.
func (m *RecordMutation) RemovedSetsIDs() (ids []int64) {
	for id := range m.removedsets {
		ids = append(ids, id)
	}
	return
}

// SetsIDs returns the "sets" edge IDs in the mutation.
func (m *RecordMutation) SetsIDs() (ids []int64) {
	for id := range m.sets {
		ids = append(ids, id)
	}
	return
}

// ResetSets resets all changes to the "sets" edge.
func (m *RecordMutation) ResetSets() {
	m.sets = nil
	m.clearedsets = false
	m.removedsets = nil
}

// Where appends a list predicates to the RecordMutation builder.
func (m *RecordMutation) Where(ps ...predicate.Record) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Record, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Record).
func (m *RecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecordMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.identifier != nil {
		fields = append(fields, record.FieldIdentifier)
	}
	if m.deleted != nil {
		fields = append(fields, record.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case record.FieldIdentifier:
		return m.Identifier()
	case record.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case record.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case record.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Record field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case record.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case record.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Record numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Record nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecordMutation) ResetField(name string) error {
	switch name {
	case record.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case record.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, record.EdgeMetadata)
	}
	if m.sets != nil {
		edges = append(edges, record.EdgeSets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case record.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case record.EdgeSets:
		ids := make([]ent.Value, 0, len(m.sets))
		for id := range m.sets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmetadata != nil {
		edges = append(edges, record.EdgeMetadata)
	}
	if m.removedsets != nil {
		edges = append(edges, record.EdgeSets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case record.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case record.EdgeSets:
		ids := make([]ent.Value, 0, len(m.removedsets))
		for id := range m.removedsets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, record.EdgeMetadata)
	}
	if m.clearedsets {
		edges = append(edges, record.EdgeSets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecordMutation) EdgeCleared(name string) bool {
	switch name {
	case record.EdgeMetadata:
		return m.clearedmetadata
	case record.EdgeSets:
		return m.clearedsets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Record unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecordMutation) ResetEdge(name string) error {
	switch name {
	case record.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case record.EdgeSets:
		m.ResetSets()
		return nil
	}
	return fmt.Errorf("unknown Record edge %s", name)
}

// SetMutation represents an operation that mutates the Set nodes in the graph.
type SetMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	set_spec        *string
	set_name        *string
	set_description *string
	clearedFields   map[string]struct{}
	records         map[int64]struct{}
	removedrecords  map[int64]struct{}
	clearedrecords  bool
	done            bool
	oldValue        func(context.Context) (*Set, error)
	predicates      []predicate.Set
}

var _ ent.Mutation = (*SetMutation)(nil)

// setOption allows management of the mutation configuration using functional options.
type setOption func(*SetMutation)

// newSetMutation creates new mutation for the Set entity.
func newSetMutation(c config, op Op, opts ...setOption) *SetMutation {
	m := &SetMutation{
		config:        c,
		op:            op,
		typ:           TypeSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetID sets the ID field of the mutation.
func withSetID(id int64) setOption {
	return func(m *SetMutation) {
		var (
			err   error
			once  sync.Once
			value *Set
		)
		m.oldValue = func(ctx context.Context) (*Set, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Set.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSet sets the old Set of the mutation.
func withSet(node *Set) setOption {
	return func(m *SetMutation) {
		m.oldValue = func(context.Context) (*Set, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Set entities.
func (m *SetMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Set.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSetSpec sets the "set_spec" field.
func (m *SetMutation) SetSetSpec(s string) {
	m.set_spec = &s
}

// SetSpec returns the value of the "set_spec" field in the mutation.
func (m *SetMutation) SetSpec() (r string, exists bool) {
	v := m.set_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSetSpec returns the old "set_spec" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldSetSpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetSpec: %w", err)
	}
	return oldValue.SetSpec, nil
}

// ResetSetSpec resets all changes to the "set_spec" field.
func (m *SetMutation) ResetSetSpec() {
	m.set_spec = nil
}

// SetSetName sets the "set_name" field.
func (m *SetMutation) SetSetName(s string) {
	m.set_name = &s
}

// SetName returns the value of the "set_name" field in the mutation.
func (m *SetMutation) SetName() (r string, exists bool) {
	v := m.set_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSetName returns the old "set_name" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldSetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetName: %w", err)
	}
	return oldValue.SetName, nil
}

// ResetSetName resets all changes to the "set_name" field.
func (m *SetMutation) ResetSetName() {
	m.set_name = nil
}

// SetSetDescription sets the "set_description" field.
func (m *SetMutation) SetSetDescription(s string) {
	m.set_description = &s
}

// SetDescription returns the value of the "set_description" field in the mutation.
func (m *SetMutation) SetDescription() (r string, exists bool) {
	v := m.set_description
	if v == nil {
		return
	}
	return *v, true
}

// OldSetDescription returns the old "set_description" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldSetDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetDescription: %w", err)
	}
	return oldValue.SetDescription, nil
}

// ClearSetDescription clears the value of the "set_description" field.
func (m *SetMutation) ClearSetDescription() {
	m.set_description = nil
	m.clearedFields[set.FieldSetDescription] = struct{}{}
}

// SetDescriptionCleared returns if the "set_description" field was cleared in this mutation.
func (m *SetMutation) SetDescriptionCleared() bool {
	_, ok := m.clearedFields[set.FieldSetDescription]
	return ok
}

// ResetSetDescription resets all changes to the "set_description" field.
func (m *SetMutation) ResetSetDescription() {
	m.set_description = nil
	delete(m.clearedFields, set.FieldSetDescription)
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *SetMutation) AddRecordIDs(ids ...int64) {
	if m.records == nil {
		m.records = make(map[int64]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *SetMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *SetMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *SetMutation) RemoveRecordIDs(ids ...int64) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *SetMutation) RemovedRecordsIDs() (ids []int64) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *SetMutation) RecordsIDs() (ids []int64) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *SetMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the SetMutation builder.
func (m *SetMutation) Where(ps ...predicate.Set) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Set, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Set).
func (m *SetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.set_spec != nil {
		fields = append(fields, set.FieldSetSpec)
	}
	if m.set_name != nil {
		fields = append(fields, set.FieldSetName)
	}
	if m.set_description != nil {
		fields = append(fields, set.FieldSetDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case set.FieldSetSpec:
		return m.SetSpec()
	case set.FieldSetName:
		return m.SetName()
	case set.FieldSetDescription:
		return m.SetDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case set.FieldSetSpec:
		return m.OldSetSpec(ctx)
	case set.FieldSetName:
		return m.OldSetName(ctx)
	case set.FieldSetDescription:
		return m.OldSetDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Set field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case set.FieldSetSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetSpec(v)
		return nil
	case set.FieldSetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetName(v)
		return nil
	case set.FieldSetDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Set numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(set.FieldSetDescription) {
		fields = append(fields, set.FieldSetDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMutation) ClearField(name string) error {
	switch name {
	case set.FieldSetDescription:
		m.ClearSetDescription()
		return nil
	}
	return fmt.Errorf("unknown Set nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMutation) ResetField(name string) error {
	switch name {
	case set.FieldSetSpec:
		m.ResetSetSpec()
		return nil
	case set.FieldSetName:
		m.ResetSetName()
		return nil
	case set.FieldSetDescription:
		m.ResetSetDescription()
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.records != nil {
		edges = append(edges, set.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecords != nil {
		edges = append(edges, set.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecords {
		edges = append(edges, set.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMutation) EdgeCleared(name string) bool {
	switch name {
	case set.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Set unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMutation) ResetEdge(name string) error {
	switch name {
	case set.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown Set edge %s", name)
}
